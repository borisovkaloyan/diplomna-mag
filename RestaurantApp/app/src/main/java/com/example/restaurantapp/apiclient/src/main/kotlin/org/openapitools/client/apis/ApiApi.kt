/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.MenuItem
import org.openapitools.client.models.Order
import org.openapitools.client.models.OrderCategory
import org.openapitools.client.models.OrderRequest
import org.openapitools.client.models.OrdersByUser
import org.openapitools.client.models.UserLogin
import org.openapitools.client.models.UserLoginResponse
import org.openapitools.client.models.UserRegistration
import org.openapitools.client.models.UserRegistrationResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class ApiApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * GET /api/menu-items/get-all-categories/
     * 
     * 
     * @return MenuItem
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiMenuItemsGetAllCategoriesRetrieve() : MenuItem {
        val localVarResponse = apiMenuItemsGetAllCategoriesRetrieveWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MenuItem
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/menu-items/get-all-categories/
     * 
     * 
     * @return ApiResponse<MenuItem?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiMenuItemsGetAllCategoriesRetrieveWithHttpInfo() : ApiResponse<MenuItem?> {
        val localVariableConfig = apiMenuItemsGetAllCategoriesRetrieveRequestConfig()

        return request<Unit, MenuItem>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiMenuItemsGetAllCategoriesRetrieve
     *
     * @return RequestConfig
     */
    fun apiMenuItemsGetAllCategoriesRetrieveRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/menu-items/get-all-categories/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/menu-items/{id}/get-item-by-id/
     * 
     * 
     * @param id A unique integer value identifying this menu item.
     * @return MenuItem
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiMenuItemsGetItemByIdRetrieve(id: kotlin.Int) : MenuItem {
        val localVarResponse = apiMenuItemsGetItemByIdRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MenuItem
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/menu-items/{id}/get-item-by-id/
     * 
     * 
     * @param id A unique integer value identifying this menu item.
     * @return ApiResponse<MenuItem?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiMenuItemsGetItemByIdRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<MenuItem?> {
        val localVariableConfig = apiMenuItemsGetItemByIdRetrieveRequestConfig(id = id)

        return request<Unit, MenuItem>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiMenuItemsGetItemByIdRetrieve
     *
     * @param id A unique integer value identifying this menu item.
     * @return RequestConfig
     */
    fun apiMenuItemsGetItemByIdRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/menu-items/{id}/get-item-by-id/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/menu-items/items-by-category/
     * 
     * 
     * @param orderCategory 
     * @return kotlin.collections.List<MenuItem>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiMenuItemsItemsByCategoryCreate(orderCategory: OrderCategory) : kotlin.collections.List<MenuItem> {
        val localVarResponse = apiMenuItemsItemsByCategoryCreateWithHttpInfo(orderCategory = orderCategory)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<MenuItem>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/menu-items/items-by-category/
     * 
     * 
     * @param orderCategory 
     * @return ApiResponse<kotlin.collections.List<MenuItem>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiMenuItemsItemsByCategoryCreateWithHttpInfo(orderCategory: OrderCategory) : ApiResponse<kotlin.collections.List<MenuItem>?> {
        val localVariableConfig = apiMenuItemsItemsByCategoryCreateRequestConfig(orderCategory = orderCategory)

        return request<OrderCategory, kotlin.collections.List<MenuItem>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiMenuItemsItemsByCategoryCreate
     *
     * @param orderCategory 
     * @return RequestConfig
     */
    fun apiMenuItemsItemsByCategoryCreateRequestConfig(orderCategory: OrderCategory) : RequestConfig<OrderCategory> {
        val localVariableBody = orderCategory
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/menu-items/items-by-category/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/menu-items/
     * 
     * 
     * @return kotlin.collections.List<MenuItem>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiMenuItemsList() : kotlin.collections.List<MenuItem> {
        val localVarResponse = apiMenuItemsListWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<MenuItem>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/menu-items/
     * 
     * 
     * @return ApiResponse<kotlin.collections.List<MenuItem>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiMenuItemsListWithHttpInfo() : ApiResponse<kotlin.collections.List<MenuItem>?> {
        val localVariableConfig = apiMenuItemsListRequestConfig()

        return request<Unit, kotlin.collections.List<MenuItem>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiMenuItemsList
     *
     * @return RequestConfig
     */
    fun apiMenuItemsListRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/menu-items/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/orders/create-order/
     * 
     * 
     * @param orderRequest 
     * @return Order
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiOrdersCreateOrderCreate(orderRequest: OrderRequest) : Order {
        val localVarResponse = apiOrdersCreateOrderCreateWithHttpInfo(orderRequest = orderRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Order
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/orders/create-order/
     * 
     * 
     * @param orderRequest 
     * @return ApiResponse<Order?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiOrdersCreateOrderCreateWithHttpInfo(orderRequest: OrderRequest) : ApiResponse<Order?> {
        val localVariableConfig = apiOrdersCreateOrderCreateRequestConfig(orderRequest = orderRequest)

        return request<OrderRequest, Order>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiOrdersCreateOrderCreate
     *
     * @param orderRequest 
     * @return RequestConfig
     */
    fun apiOrdersCreateOrderCreateRequestConfig(orderRequest: OrderRequest) : RequestConfig<OrderRequest> {
        val localVariableBody = orderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/orders/create-order/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/orders/latest-order/
     * 
     * 
     * @return Order
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiOrdersLatestOrderRetrieve() : Order {
        val localVarResponse = apiOrdersLatestOrderRetrieveWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Order
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/orders/latest-order/
     * 
     * 
     * @return ApiResponse<Order?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiOrdersLatestOrderRetrieveWithHttpInfo() : ApiResponse<Order?> {
        val localVariableConfig = apiOrdersLatestOrderRetrieveRequestConfig()

        return request<Unit, Order>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiOrdersLatestOrderRetrieve
     *
     * @return RequestConfig
     */
    fun apiOrdersLatestOrderRetrieveRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/orders/latest-order/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/orders/orders-by-user/
     * 
     * 
     * @param ordersByUser 
     * @return kotlin.collections.List<Order>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiOrdersOrdersByUserCreate(ordersByUser: OrdersByUser) : kotlin.collections.List<Order> {
        val localVarResponse = apiOrdersOrdersByUserCreateWithHttpInfo(ordersByUser = ordersByUser)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Order>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/orders/orders-by-user/
     * 
     * 
     * @param ordersByUser 
     * @return ApiResponse<kotlin.collections.List<Order>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiOrdersOrdersByUserCreateWithHttpInfo(ordersByUser: OrdersByUser) : ApiResponse<kotlin.collections.List<Order>?> {
        val localVariableConfig = apiOrdersOrdersByUserCreateRequestConfig(ordersByUser = ordersByUser)

        return request<OrdersByUser, kotlin.collections.List<Order>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiOrdersOrdersByUserCreate
     *
     * @param ordersByUser 
     * @return RequestConfig
     */
    fun apiOrdersOrdersByUserCreateRequestConfig(ordersByUser: OrdersByUser) : RequestConfig<OrdersByUser> {
        val localVariableBody = ordersByUser
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/orders/orders-by-user/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/users/login/
     * 
     * 
     * @param userLogin 
     * @return UserLoginResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiUsersLoginCreate(userLogin: UserLogin) : UserLoginResponse {
        val localVarResponse = apiUsersLoginCreateWithHttpInfo(userLogin = userLogin)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserLoginResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/users/login/
     * 
     * 
     * @param userLogin 
     * @return ApiResponse<UserLoginResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiUsersLoginCreateWithHttpInfo(userLogin: UserLogin) : ApiResponse<UserLoginResponse?> {
        val localVariableConfig = apiUsersLoginCreateRequestConfig(userLogin = userLogin)

        return request<UserLogin, UserLoginResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiUsersLoginCreate
     *
     * @param userLogin 
     * @return RequestConfig
     */
    fun apiUsersLoginCreateRequestConfig(userLogin: UserLogin) : RequestConfig<UserLogin> {
        val localVariableBody = userLogin
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/users/login/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/users/register/
     * 
     * 
     * @param userRegistration 
     * @return UserRegistrationResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiUsersRegisterCreate(userRegistration: UserRegistration) : UserRegistrationResponse {
        val localVarResponse = apiUsersRegisterCreateWithHttpInfo(userRegistration = userRegistration)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserRegistrationResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/users/register/
     * 
     * 
     * @param userRegistration 
     * @return ApiResponse<UserRegistrationResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiUsersRegisterCreateWithHttpInfo(userRegistration: UserRegistration) : ApiResponse<UserRegistrationResponse?> {
        val localVariableConfig = apiUsersRegisterCreateRequestConfig(userRegistration = userRegistration)

        return request<UserRegistration, UserRegistrationResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiUsersRegisterCreate
     *
     * @param userRegistration 
     * @return RequestConfig
     */
    fun apiUsersRegisterCreateRequestConfig(userRegistration: UserRegistration) : RequestConfig<UserRegistration> {
        val localVariableBody = userRegistration
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/users/register/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
